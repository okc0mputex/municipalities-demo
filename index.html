<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>stlite + Streamlit</title>
    
    <style>
      html, body, #root { height: 100%; margin: 0; }
      #status { position: fixed; top: 8px; left: 8px; background: rgba(0,0,0,0.7); color: #fff; padding: 8px 10px; border-radius: 6px; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; z-index: 9999; }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <div id="status">Loading…</div>
    <script type="module">
      const rootEl = document.getElementById("root");
      const statusEl = document.getElementById("status");

      async function loadScript(src) {
        return new Promise((resolve, reject) => {
          const s = document.createElement("script");
          s.src = src;
          s.async = true;
          s.crossOrigin = "anonymous";
          s.onload = resolve;
          s.onerror = reject;
          document.head.appendChild(s);
        });
      }

      async function getMount() {
        // 1) Prefer local vendored ESM (same-origin, no CORS/MIME issues)
        try {
          const local = await import("/stlite/stlite.js");
          return local.mount;
        } catch (_localErr) {}

        // 2) Fall back to CDN ESM, then global
        const cdnCandidates = [
          "https://unpkg.com/@stlite/browser@0.89.1/build/stlite.js",
          "https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/build/stlite.js",
        ];
        for (const url of cdnCandidates) {
          try {
            const mod = await import(url);
            return mod.mount;
          } catch {}
        }
        const legacyCandidates = [
          "https://unpkg.com/@stlite/browser@0.89.1/dist/stlite.js",
          "https://cdn.jsdelivr.net/npm/@stlite/browser@0.89.1/dist/stlite.js",
        ];
        for (const url of legacyCandidates) {
          try {
            await loadScript(url);
            if (window.stlite && typeof window.stlite.mount === "function") {
              return window.stlite.mount;
            }
          } catch {}
        }
        throw new Error("Failed to load stlite (local and CDNs)");
      }

      async function loadFileAsArrayBuffer(path) {
        const res = await fetch(path);
        if (!res.ok) return null;
        return await res.arrayBuffer();
      }

      async function main() {
        const mount = await getMount();
        statusEl.textContent = "Loading app.py…";
        const code = await fetch("app.py").then(r => r.text());
        const encoder = new TextEncoder();
        statusEl.textContent = "Preloading CSV files…";

        // Preload cleaned CSVs into the in-browser filesystem for immediate use
        const csvFilenames = [
          "Στοιχεία Συμβάσεων_Demo Έκδοση__Raw_Data.csv",
          "Στοιχεία Συμβάσεων_Demo Έκδοση__Widget_Γενική_Επισκόπηση.csv",
          "Στοιχεία Συμβάσεων_Demo Έκδοση__Widget_Συμβάσεις.csv",
          "Στοιχεία Συμβάσεων_Demo Έκδοση__Λίστα.csv",
        ];

        const files = {};
        for (const name of csvFilenames) {
          const buf = await loadFileAsArrayBuffer(`clean_csv/${encodeURIComponent(name)}`);
          if (buf) {
            // Place under clean_csv/ so Path("clean_csv").glob("*.csv") works in app.py
            files[`clean_csv/${name}`] = new Uint8Array(buf);
          }
        }
        // Add entrypoint file
        files["app.py"] = encoder.encode(code);

        statusEl.textContent = "Starting Python runtime…";
        try {
          await mount(
            {
              entrypoint: "app.py",
              files,
              requirements: ["pandas", "numpy", "plotly", "openpyxl"],
            },
            rootEl
          );
          statusEl.remove();
        } catch (err) {
          console.error(err);
          statusEl.textContent = "Error: " + (err && err.message ? err.message : String(err));
        }
      }

      main();
    </script>
  </body>
  </html>

